# 🧾 词法分析器 详细说明

## 📌 一、概述

本词法分析器使用 Java 实现，主要功能是将输入的 **C 语言子集源代码** 分解为一系列有意义的**词法单元（Token）**。这些 Token 是语法分析的基础单位，代表源代码中不可再分的基本元素，如：

🔑 关键字、🆔 标识符、🔢 常量、➕ 运算符、📍 界符 等。

本分析器使用 **正则表达式** 定义词法规则，并按顺序扫描源代码进行匹配与解析。

---

## 🧱 二、核心组成

词法分析器包含两个主要类：

| 类名           | 说明           |
| ------------ | ------------ |
| `Token.java` | 定义 Token 的结构 |
| `Lexer.java` | 实现词法分析的核心逻辑  |

---

### 🔹 2.1 `Token.java`

用于表示一个 Token（词法单元）。

* **属性**:

    * `type`：词法类型（如 `"KW_INT"`, `"ID"`, `"NUM"`）
    * `value`：源代码中实际的文本值（如 `"int"`, `"x"`, `"123"`）

* **构造方法**:

  ```java
  public Token(String type, String value);
  ```

* **方法**:

    * `toString()`：返回格式为 `(type, value)` 的字符串，便于调试和日志输出。

---

### 🔸 2.2 `Lexer.java`

负责执行词法分析逻辑，核心结构包括：

#### 🔍 内部结构

* **`TokenRule`（私有 record 类）**：

    * 封装单条词法规则
    * 成员:

        * `Pattern pattern`: 匹配正则表达式
        * `String type`: 匹配成功后对应的 Token 类型（`null` 表示忽略）

* **`TOKEN_RULES`**：

    * 类型：`List<TokenRule>`
    * 存储所有 TokenRule，按优先级顺序匹配

* **静态初始化块**：

    * 使用 `addTokenRule(String regex, String type)` 添加规则
    * `type == null` 表示该规则不生成 Token（如注释）

---

## 🔁 三、词法分析流程

主方法：

```java
public static List<Token> lex(String input){}
```

### ✅ 分析步骤：

1. **初始化**：

    * 创建空的 `List<Token>`
    * 指针 `pos = 0`

2. **扫描输入字符串**：

    * 遍历直到末尾

   每轮处理：

    * ✨ **跳过空白字符**（如空格、`\n`、`\t`）
    * 🔎 **逐条匹配规则**：

        * 使用 `matcher.lookingAt()` 从当前位置开始匹配
        * 若匹配成功：

            * 获取匹配值
            * 若 `type != null`，生成并添加 Token
            * 移动 `pos`
        * 若无匹配：❗ 抛出错误异常

3. **完成后返回**：

    * 所有 Token 构成的列表

---

## 📖 四、预定义词法规则

### 🔑 4.1 关键字（Keywords）

| 正则表达式        | Token 类型    |
| ------------ | ----------- |
| `\bint\b`    | `KW_INT`    |
| `\bmain\b`   | `KW_MAIN`   |
| `\bwhile\b`  | `KW_WHILE`  |
| `\bif\b`     | `KW_IF`     |
| `\belse\b`   | `KW_ELSE`   |
| `\breturn\b` | `KW_RETURN` |
| `\bscanf\b`  | `IO_SCANF`  |
| `\bprintf\b` | `IO_PRINTF` |

> 📌 使用 `\b` 保证匹配完整单词，避免误匹配 `integer` 中的 `int`。

---

### 🆔 4.2 标识符与数字

| 正则表达式                    | Token 类型 |
| ------------------------ | -------- |
| `[a-zA-Z_][a-zA-Z0-9_]*` | `ID`     |
| `\d+`                    | `NUM`    |

---

### ⚙️ 4.3 运算符（Operators）

| 正则表达式 | Token 类型    |
| ----- | ----------- |
| `\+`  | `OP_ADD`    |
| `-`   | `OP_SUB`    |
| `\*`  | `OP_MUL`    |
| `/`   | `OP_DIV`    |
| `%`   | `OP_MOD`    |
| `==`  | `OP_EQ`     |
| `=`   | `OP_ASSIGN` |
| `<=`  | `OP_LE`     |
| `>`   | `OP_GT`     |

---

### 🧩 4.4 界符（Delimiters）

| 正则表达式 | Token 类型    |
| ----- | ----------- |
| `\(`  | `LPAREN`    |
| `\)`  | `RPAREN`    |
| `\{`  | `LBRACE`    |
| `\}`  | `RBRACE`    |
| `;`   | `SEMICOLON` |
| `,`   | `COMMA`     |
| `&`   | `AMPERSAND` |

---

### 💬 4.5 字符串常量（Strings）

| 正则表达式     | Token 类型    |       |
| --------- | ----------- | ----- |
| \`"(\\\\" | \[^"])\*"\` | `STR` |

> ✅ 支持转义双引号 `\\"`，匹配以双引号包裹的字符串。

---

### 🧹 4.6 注释（忽略）

| 正则表达式              | Token 类型 |
| ------------------ | -------- |
| `//.*`             | `null`   |
| `/\*[\\s\\S]*?\*/` | `null`   |

> 忽略单行 `//` 注释 和 多行 `/* ... */` 注释。

---

## ⚠️ 五、错误处理机制

若某字符无法匹配任一规则，将抛出：

```bash
Lexer Error: 非法字符 '{char}' at position {index}
```

这有助于快速定位源代码中的语法错误或不合法字符。

---

## 🌟 六、功能亮点总结

| 功能             | 支持情况 |
| -------------- | ---- |
| ✅ 基于正则表达式定义规则  | ✔️   |
| ✅ 支持 C 语言常用关键字 | ✔️   |
| ✅ 忽略空白和注释      | ✔️   |
| ✅ 支持字符串与转义字符   | ✔️   |
| ✅ 错误提示清晰       | ✔️   |

